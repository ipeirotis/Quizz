package us.quizz.service;

import com.google.inject.Inject;

import us.quizz.entities.ExplorationExploitationResult;
import us.quizz.entities.SurvivalProbabilityResult;
import us.quizz.ofy.OfyBaseService;
import us.quizz.repository.ExplorationExploitationResultRepository;
import us.quizz.repository.QuizPerformanceRepository;
import us.quizz.repository.SurvivalProbabilityResultRepository;
import us.quizz.utils.CachePMF;
import us.quizz.utils.Helper;
import us.quizz.utils.MemcacheKey;

import java.text.NumberFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;
import java.util.logging.Level;
import java.util.logging.Logger;

// TODO(chunhowt): Write unit tests for ExplorationExploitationService.
public class ExplorationExploitationService extends OfyBaseService<ExplorationExploitationResult> {
  private static Logger logger = Logger.getLogger(ExplorationExploitationService.class.getName());
  private Map<Integer, Map<Integer, Map<Integer, Double>>> values;
  private Map<Integer, Map<Integer, Map<Integer, Double>>> exploreValues;
  private Map<Integer, Map<Integer, Map<Integer, Double>>> exploitValues;
  private Map<Integer, Map<Integer, Map<Integer, Boolean>>> actions;

  private Integer N;
  // We either use the IG per se, or the IG-VIG to accommodate for value of learning.
  private static boolean useIG = false;
  // The accuracy threshold for convergence
  private static double EPSILON = 0.01;
  // Number of minutes to cache the actions in Memcache.
  private static final int CACHED_TIME_MINS = 24 * 60;  // 24 hours.
  // How much ahead to look in exploration/exploitation
  private static final int HORIZON = 20;  // 24 hours.

  private SurvivalProbabilityService survivalProbabilityService;

  @Inject
  public ExplorationExploitationService(SurvivalProbabilityService survivalProbabilityService,
      ExplorationExploitationResultRepository explorationExploitationResultRepository) {
    super(explorationExploitationResultRepository);
    this.survivalProbabilityService = survivalProbabilityService;
    cleanCache();
  }

  public void cacheValuesInMemcache(int numCorrect, int numIncorrect, int numExploit) {
    String key = MemcacheKey.getExploreExploitAction(numCorrect, numIncorrect, numExploit, this.N);
    ExplorationExploitationResult r = getUtility(numCorrect, numIncorrect, numExploit);
    CachePMF.put(key, r, CACHED_TIME_MINS * 60);
    logger.log(Level.INFO, r.print());
  }

  public void saveValuesInDatastore(int numCorrect, int numIncorrect, int numExploit) {
    String key = MemcacheKey.getExploreExploitAction(numCorrect, numIncorrect, numExploit, this.N);
    ExplorationExploitationResult r = CachePMF.get(key, ExplorationExploitationResult.class);
    save(r);
  }

  private void cleanCache() {
    this.values = new HashMap<Integer, Map<Integer, Map<Integer, Double>>>();
    this.exploreValues = new HashMap<Integer, Map<Integer, Map<Integer, Double>>>();
    this.exploitValues = new HashMap<Integer, Map<Integer, Map<Integer, Double>>>();
    this.actions = new HashMap<Integer, Map<Integer, Map<Integer, Boolean>>>();
  }

  // Computes the exploration exploitation results given the stats and save them in the maps
  // in this class. Returns the maximum utility we can get from either the explore or exploit
  // action.
  // Params:
  //   Uq: utility.
  //   limit: The number of exploration-exploitation lookahead allowed.
  private double computeValue(
      Integer numCorrect, Integer numIncorrect, Integer numExploit, Double Uq, int limit) {
    if (limit == 0) {
      return 0;
    }

    Double result = getCachedValue(numCorrect, numIncorrect, numExploit, this.values);
    if (result != null) {
      return result;
    }

    double Uexploit = 0.0;
    double Uexplore = 0.0;
    try {
      // First we compute the utility if we do "exploit" action.
      double ig = Helper.getBayesianMeanInformationGain(numCorrect + 1, numIncorrect + (N - 1), N);
      double vig = Helper.getBayesianInformationGainSquare(
          numCorrect + 1, numIncorrect + (N - 1), N);

      double UexploitNow = useIG ? ig : (ig - 0.75 * Math.sqrt(vig));
      double UexploitFuture = computeValue(
          numCorrect, numIncorrect, numExploit + 1, UexploitNow, limit - 1);
      double gammaExploit = probSurvive(numCorrect, numIncorrect, numExploit,
                                        numCorrect, numIncorrect, numExploit + 1);
      Uexploit = gammaExploit * (UexploitNow + UexploitFuture);

      // Then, we compute the utility if we do "explore" action.
      double q = (numCorrect + 1.0) / (numCorrect + numIncorrect + N);

      double igCorr = Helper.getBayesianMeanInformationGain(
          numCorrect + 1, numIncorrect + (N - 1), N);
      double vigCorr = Helper.getBayesianInformationGainSquare(
          numCorrect + 1, numIncorrect + (N - 1), N);
      double UquestionCorr = useIG ? igCorr : (igCorr - 0.75 * Math.sqrt(vigCorr));
      double UexploreNowCorr = numExploit * (UquestionCorr - Uq);
      double UexploreFutureCorr = computeValue(
          numCorrect + 1, numIncorrect, numExploit, UquestionCorr, limit - 1);
      double UexploreCorr = q * (UexploreNowCorr + UexploreFutureCorr);

      double igIncorr = Helper.getBayesianMeanInformationGain(
          numCorrect, numIncorrect + 1 + (N - 1), N);
      double vigIncorr = Helper.getBayesianInformationGainSquare(
          numCorrect, numIncorrect + 1 + (N - 1), N);
      double UquestionIncorr = useIG ? igIncorr : (igIncorr - 0.75 * Math.sqrt(vigIncorr));
      double UexploreNowIncorr = numExploit * (UquestionIncorr - Uq);
      double UexploreFutureIncorr = computeValue(
          numCorrect, numIncorrect + 1, numExploit, UquestionIncorr, limit - 1);
      double UexploreIncorr = (1 - q) * (UexploreNowIncorr + UexploreFutureIncorr);

      double gammaExploreCorr = probSurvive(numCorrect, numIncorrect, numExploit,
                                            numCorrect + 1, numIncorrect, numExploit);
      double gammaExploreIncorr = probSurvive(numCorrect, numIncorrect, numExploit,
                                              numCorrect, numIncorrect + 1, numExploit);
      Uexplore = gammaExploreCorr * UexploreCorr + gammaExploreIncorr * UexploreIncorr;
    } catch (Exception e) {
      logger.log(Level.SEVERE, e.getMessage());
    }

    result = Math.max(Uexploit, Uexplore);
    putCachedValue(numCorrect, numIncorrect, numExploit, result, this.values);
    putCachedValue(numCorrect, numIncorrect, numExploit, Uexploit, this.exploitValues);
    putCachedValue(numCorrect, numIncorrect, numExploit, Uexplore, this.exploreValues);
    putCachedValue(numCorrect, numIncorrect, numExploit, (Uexploit > Uexplore), this.actions);
    return result;
  }

  // Returns the exploration exploitation action given the number of correct, incorrect and exploits
  // so far. First, look into the memcache, then into the datastore, if not found, create a default
  // action which is "explore".
  public ExplorationExploitationResult getAction(
      Integer numCorrect, Integer numIncorrect, Integer numExploit) {
    String key = MemcacheKey.getExploreExploitAction(numCorrect, numIncorrect, numExploit, this.N);
    ExplorationExploitationResult r = CachePMF.get(key, ExplorationExploitationResult.class);

    if (r == null) {
      r = get(ExplorationExploitationResult.generateId(numCorrect, numIncorrect, numExploit));
      if (r == null) {
        r = new ExplorationExploitationResult(numCorrect, numIncorrect, numExploit);
        r.setActionExploit(false);
      }
    }
    return r;
  }

  // Computes the exploration exploitation result given the stats of numCorrect, numIncorrect and
  // numExploit iteratively until the difference between exploration and exploitation utility is
  // small enough or the number of iteration reaches the HORIZON.
  private ExplorationExploitationResult getUtility(
      Integer numCorrect, Integer numIncorrect, Integer numExploit) {
    double diff = Double.MAX_VALUE;
    double diffExplore = Double.MAX_VALUE;
    double diffExploit = Double.MAX_VALUE;
    int i = 1;
    cleanCache();
    computeValue(numCorrect, numIncorrect, numExploit, 0.0, i);
    Double explore = getCachedValue(numCorrect, numIncorrect, numExploit, this.exploreValues);
    Double exploit = getCachedValue(numCorrect, numIncorrect, numExploit, this.exploitValues);
    do {
      i++;
      if (i > HORIZON)
        break;
      double tExplore = explore;
      double tExploit = exploit;
      cleanCache();
      computeValue(numCorrect, numIncorrect, numExploit, 0.0, i);
      explore = getCachedValue(numCorrect, numIncorrect, numExploit, this.exploreValues);
      exploit = getCachedValue(numCorrect, numIncorrect, numExploit, this.exploitValues);
      diffExplore = Math.abs(explore - tExplore);
      diffExploit = Math.abs(exploit - tExploit);
      diff = Math.abs(explore - exploit);
    } while (diffExplore > EPSILON || diffExploit > EPSILON ||
             diff < diffExplore || diff < diffExploit);

    ExplorationExploitationResult r = new ExplorationExploitationResult(
        numCorrect, numIncorrect, numExploit);
    r.setActionExploit(getCachedValue(numCorrect, numIncorrect, numExploit, this.actions));
    r.setUtility(getCachedValue(numCorrect, numIncorrect, numExploit, this.values));
    r.setExploitUtility(getCachedValue(numCorrect, numIncorrect, numExploit, this.exploitValues));
    r.setExploreUtility(getCachedValue(numCorrect, numIncorrect, numExploit, this.exploreValues));
    r.setIterations(i);
    r.setTimestamp(new Date());

    return r;
  }

  // Returns the empirical probability survival given the stats.
  private double probSurvive(
      Integer fromNumCorrect, Integer fromNumIncorrect, Integer fromNumExploit,
      Integer toNumCorrect, Integer toNumIncorrect, Integer toNumExploit) {
    // TODO (Panos): Since we do not have sufficient statistics for the exploit actions, the
    // function does not use the fromNumExploit and toNumExploit values
    // We should modify the survivalProbablity service to control for that.
    SurvivalProbabilityResult result = survivalProbabilityService.getSurvivalProbability(
        null  /* quizID */, fromNumCorrect, toNumCorrect,
        fromNumIncorrect, toNumIncorrect, fromNumExploit, toNumExploit);
    double pSurvival = result.getProbSurvival();

    // TODO: The Math.pow(0.5, toNumExploit - fromNumExploit) part is just to add a discounting
    // factor for the exploit actions.
    return Math.pow(0.5, toNumExploit - fromNumExploit) * pSurvival;
  }

  // A util function to return the value pointed by the numCorrect, numIncorrect, numExploit in
  // the map.
  private<T> T getCachedValue(Integer numCorrect, Integer numIncorrect, Integer numExploit,
      Map<Integer, Map<Integer, Map<Integer, T>>> mapResults) {
    Map<Integer, Map<Integer, T>> correctMap = mapResults.get(numCorrect);
    if (correctMap == null) {
      return null;
    }
    Map<Integer, T> incorrectMap = correctMap.get(numIncorrect);
    if (incorrectMap == null) {
      return null;
    }
    return incorrectMap.get(numExploit);
  }

  // A util function to put the value given into the mapResults.
  private<T> void putCachedValue(
      Integer numCorrect, Integer numIncorrect, Integer numExploit, T value,
      Map<Integer, Map<Integer, Map<Integer, T>>> mapResults) {
    Map<Integer, Map<Integer, T>> correctMap;
    Map<Integer, T> incorrectMap;

    correctMap = mapResults.get(numCorrect);
    if (correctMap == null) {
      correctMap = new HashMap<Integer, Map<Integer, T>>();
      incorrectMap = new HashMap<Integer, T>();
    } else {
      incorrectMap = correctMap.get(numIncorrect);
      if (incorrectMap == null) {
        incorrectMap = new HashMap<Integer, T>();
      }
    }
    incorrectMap.put(numExploit, value);
    correctMap.put(numIncorrect, incorrectMap);
    mapResults.put(numCorrect, correctMap);
  }

  public void setN(Integer n) {
    N = n;
  }
}
