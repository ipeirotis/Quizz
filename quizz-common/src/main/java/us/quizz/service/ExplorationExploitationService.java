package us.quizz.service;

import com.google.inject.Inject;

import us.quizz.repository.QuizPerformanceRepository;
import us.quizz.utils.CachePMF;
import us.quizz.utils.Helper;
import us.quizz.utils.MemcacheKey;

import java.text.NumberFormat;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

public class ExplorationExploitationService {
  @SuppressWarnings("unused")
  private static final Logger logger =
      Logger.getLogger(ExplorationExploitationService.class.getName());

  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> values;
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> exploreValues;
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> exploitValues;
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Boolean>>> actions;
  private Integer N;

  // We either use the IG per se, or the IG-VIG to accommodate for value of learning
  private static boolean useIG = false;
  // The accuracy threshold for convergence
  private static double EPSILON = 0.01;
//Number of minutes to cache the actions in Memcache.
 private static final int CACHED_TIME_MINS = 24 * 60;  // 24 hours.

  
  private SurvivalProbabilityService survivalProbabilityService;

  @Inject
  public ExplorationExploitationService(SurvivalProbabilityService survivalProbabilityService) {
    this.survivalProbabilityService = survivalProbabilityService;
    cleanCache();
  }

  public void cleanCache() {
    this.values = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
    this.exploreValues = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
    this.exploitValues = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
    this.actions = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Boolean>>>();
  }

  private Double getCachedValue(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Double>> mapA = this.values.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Double> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private void putCachedValue(Integer a, Integer b, Integer c, Double value) {
    HashMap<Integer, HashMap<Integer, Double>> mapA;
    HashMap<Integer, Double> mapB;

    mapA = this.values.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Double>>();
      mapB = new HashMap<Integer, Double>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Double>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.values.put(a, mapA);
  }

  private Double getCachedExploreValue(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Double>> mapA = this.exploreValues.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Double> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private void putCachedExploreValue(Integer a, Integer b, Integer c, Double value) {
    HashMap<Integer, HashMap<Integer, Double>> mapA;
    HashMap<Integer, Double> mapB;

    mapA = this.exploreValues.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Double>>();
      mapB = new HashMap<Integer, Double>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Double>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.exploreValues.put(a, mapA);
  }

  private Double getCachedExploitValue(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Double>> mapA = this.exploitValues.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Double> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private void putCachedExploitValue(Integer a, Integer b, Integer c, Double value) {
    HashMap<Integer, HashMap<Integer, Double>> mapA;
    HashMap<Integer, Double> mapB;

    mapA = this.exploitValues.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Double>>();
      mapB = new HashMap<Integer, Double>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Double>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.exploitValues.put(a, mapA);
  }

  private Boolean getCachedAction(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Boolean>> mapA = this.actions.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Boolean> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private void putCachedAction(Integer a, Integer b, Integer c, Boolean value) {
    HashMap<Integer, HashMap<Integer, Boolean>> mapA;
    HashMap<Integer, Boolean> mapB;

    mapA = this.actions.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Boolean>>();
      mapB = new HashMap<Integer, Boolean>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Boolean>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.actions.put(a, mapA);
  }

  private Set<String> set = new HashSet<String>();

  public Set<String> getSet() {
    return set;
  }

  private double probSurvive(Integer a_from, Integer b_from, Integer c_from,
                             Integer a_to, Integer b_to, Integer c_to) {
	  
	  
    us.quizz.service.SurvivalProbabilityService.Result result 
      = survivalProbabilityService.getSurvivalProbability(null, a_from, a_to, b_from, b_to);
    double pSurvival = result.getPsurvival();

    return pSurvival;

  }

  private double computeValue(Integer a, Integer b, Integer c, Double Uq, int limit) {
	  
	  
	  
    if (limit == 0) {
      return 0;
    }

    Double result = getCachedValue(a, b, c);
    if (result != null) {
      return result;
    }

    
    double Uexploit = 0.0;
	double Uexplore = 0.0;
	try {
		double ig = Helper.getBayesianMeanInformationGain(a + 1, b + (N - 1), N);
		double vig = Helper.getBayesianInformationGainSquare(a + 1, b + (N - 1), N);

		double UexploitNow = useIG? ig : (ig - 0.75 * Math.sqrt(vig));
		double UexploitFuture = computeValue(a, b, c + 1, UexploitNow, limit - 1);

		double gammaExploit = probSurvive(a, b, c, a, b, c+1);
		Uexploit = gammaExploit * (UexploitNow + UexploitFuture);

		double q = (a + 1.0) / (a + b + N);

		double igCorr = Helper.getBayesianMeanInformationGain(a + 1, b + (N - 1), N);
		double vigCorr = Helper.getBayesianInformationGainSquare(a + 1, b + (N - 1), N);
		double UquestionCorr = useIG? igCorr : (igCorr - 0.75 * Math.sqrt(vigCorr));
		double UexploreNowCorr = c * (UquestionCorr - Uq);

		double UexploreFutureCorr = computeValue(a + 1, b, c, UquestionCorr, limit - 1);
		double UexploreCorr = q * (UexploreNowCorr + UexploreFutureCorr);

		double igIncorr = Helper.getBayesianMeanInformationGain(a, b + 1 + (N - 1), N);
		double vigIncorr = Helper.getBayesianInformationGainSquare(a, b + 1 + (N - 1), N);
		double UquestionIncorr = useIG? igIncorr : (igIncorr - 0.75 * Math.sqrt(vigIncorr));
		double UexploreNowIncorr = c * (UquestionIncorr - Uq);
		double UexploreFutureIncorr = computeValue(a, b + 1, c, UquestionIncorr, limit - 1);
		double UexploreIncorr = (1 - q) * (UexploreNowIncorr + UexploreFutureIncorr);

		double gammaExploreCorr = probSurvive(a, b, c, a+1, b, c);
		double gammaExploreIncorr = probSurvive(a, b, c, a, b+1, c);

		Uexplore = gammaExploreCorr * UexploreCorr + gammaExploreIncorr * UexploreIncorr;
	} catch (Exception e) {
		// TODO Auto-generated catch block
		e.printStackTrace();
	}

    result = Math.max(Uexploit, Uexplore);
    putCachedValue(a, b, c, result);
    putCachedExploitValue(a, b, c, Uexploit);
    putCachedExploreValue(a, b, c, Uexplore);
    putCachedAction(a, b, c, (Uexploit < Uexplore));
    return result;
  }

  private Result getUtility(Integer a, Integer b, Integer c) {
    double diff = Double.MAX_VALUE;
    double diffExplore = Double.MAX_VALUE;
    double diffExploit = Double.MAX_VALUE;
    int i = 1;
    computeValue(a, b, c, 0.0, i);
    Double explore = getCachedExploreValue(a, b, c);
    Double exploit = getCachedExploitValue(a, b, c);
    do {
      i++;
      double tExplore = explore;
      double tExploit = exploit;
      cleanCache();
      computeValue(a, b, c, 0.0, i);
      explore = getCachedExploreValue(a, b, c);
      exploit = getCachedExploitValue(a, b, c);
      diffExplore = Math.abs(explore - tExplore);
      diffExploit = Math.abs(exploit - tExploit);
      diff = Math.abs(explore - exploit);
    } while (diffExplore > EPSILON ||
             diffExploit > EPSILON ||
             diff < diffExplore ||
             diff < diffExploit);

    Result r = new Result();
    r.a = a;
    r.b = b;
    r.c = c;
    r.value = getCachedValue(a, b, c);
    r.actionExploit = getCachedAction(a, b, c);
    r.exploit = getCachedExploitValue(a, b, c);
    r.explore = getCachedExploreValue(a, b, c);
    r.iterations = i;

    return r;
  }

  public Result getAction(Integer a, Integer b, Integer c) {
	    String key = MemcacheKey.getExploreExploitAction(a,b,c, this.N);
	    Result result = CachePMF.get(key, Result.class);
	    if (result !=null) {
	    	return result;
	    } else {
	    	Result r = new Result();
    	    r.actionExploit = false;
    	    return r;
	    }
  }
  
  
  public void cacheValuesInMemcache(Integer a, Integer b, Integer c) {
	  String key = MemcacheKey.getExploreExploitAction(a,b,c, this.N);
	  Result r = getUtility(a, b, c);
	  CachePMF.put(key, r, CACHED_TIME_MINS * 60);
  }

  public static void main(String[] args)  {
    NumberFormat format = NumberFormat.getInstance();
    format.setMinimumFractionDigits(3);
    format.setMaximumFractionDigits(3);
   
    int n = 4;
    
    QuizPerformanceRepository qp = new QuizPerformanceRepository();
    SurvivalProbabilityService s = new SurvivalProbabilityService(qp);
    ExplorationExploitationService t = new ExplorationExploitationService(s);
    t.setN(n);


    int limit = 15;
    for (int k = 0; k < 5; k++) {
      for (int i = 0; i < limit; i++) {
        for (int j = 0; j < limit; j++) {
          Result r = t.getUtility(i, j, k);
          System.out.print(r.toString() + "\t");
        }
        System.out.println("");
      }
      System.out.println("");
    }
  }
  
  public class Result {
    Integer a, b, c;
    Double value;
    Integer iterations;
    
    public Integer getA() {
		return a;
	}

	public void setA(Integer a) {
		this.a = a;
	}

	public Integer getB() {
		return b;
	}

	public void setB(Integer b) {
		this.b = b;
	}

	public Boolean getActionExploit() {
		return actionExploit;
	}

	public void setActionExploit(Boolean actionExploit) {
		this.actionExploit = actionExploit;
	}

	public Integer getC() {
		return c;
	}

	public void setC(Integer c) {
		this.c = c;
	}

	public Double getValue() {
		return value;
	}

	public void setValue(Double value) {
		this.value = value;
	}

	public Double getExplore() {
		return explore;
	}

	public void setExplore(Double explore) {
		this.explore = explore;
	}

	public Double getExploit() {
		return exploit;
	}

	public void setExploit(Double exploit) {
		this.exploit = exploit;
	}

	public Integer getIterations() {
		return iterations;
	}

	public void setIterations(Integer iterations) {
		this.iterations = iterations;
	}

	Boolean actionExploit;
    Double explore;
    Double exploit;

    public String toString() {
      NumberFormat format = NumberFormat.getInstance();
      format.setMinimumFractionDigits(4);
      format.setMaximumFractionDigits(4);

      StringBuffer sb = new StringBuffer();
      sb.append("[" + a + "," + b + "," + c + "]: V=");
      sb.append(format.format(value));
      sb.append("/R=");
      sb.append(format.format(explore));
      sb.append("/T=");
      sb.append(format.format(exploit));
      sb.append("/Exploit=");
      sb.append(actionExploit + "\t");

      return sb.toString();
    }


  }

  public void setN(Integer n) {
    N = n;
  }
}
