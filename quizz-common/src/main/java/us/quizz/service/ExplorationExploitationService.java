package us.quizz.service;

import java.text.NumberFormat;
import java.util.HashMap;
import java.util.logging.Logger;

import com.google.inject.Inject;

import us.quizz.utils.Helper;

public class ExplorationExploitationService {
	@SuppressWarnings("unused")
	private static final Logger logger = Logger.getLogger(ExplorationExploitationService.class.getName());

	private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> values;
	private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> exploreValues;
	private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> exploitValues;
	private HashMap<Integer, HashMap<Integer, HashMap<Integer, Boolean>>> actions;
	private Integer N;
	
	private SurvivalProbabilityService survivalProbabilityService;
	
	@Inject
	public ExplorationExploitationService(SurvivalProbabilityService survivalProbabilityService){
		this.survivalProbabilityService = survivalProbabilityService;
		cleanCache();
	}

	public void cleanCache() {
		this.values = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
		this.exploreValues = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
		this.exploitValues = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
		this.actions = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Boolean>>>();
	}

	private Double getCachedValue(Integer a, Integer b, Integer c) {
		HashMap<Integer, HashMap<Integer, Double>> mapA = this.values.get(a);
		if (mapA == null)
			return null;
		HashMap<Integer, Double> mapB = mapA.get(b);
		if (mapB == null)
			return null;
		return mapB.get(c);
	}

	private void putCachedValue(Integer a, Integer b, Integer c, Double value) {
		HashMap<Integer, HashMap<Integer, Double>> mapA;
		HashMap<Integer, Double> mapB;

		mapA = this.values.get(a);
		if (mapA == null) {
			mapA = new HashMap<Integer, HashMap<Integer, Double>>();
			mapB = new HashMap<Integer, Double>();
		} else {
			mapB = mapA.get(b);
			if (mapB == null) {
				mapB = new HashMap<Integer, Double>();
			}
		}
		mapB.put(c, value);
		mapA.put(b, mapB);
		this.values.put(a, mapA);
	}

	private Double getCachedExploreValue(Integer a, Integer b, Integer c) {
		HashMap<Integer, HashMap<Integer, Double>> mapA = this.exploreValues
				.get(a);
		if (mapA == null)
			return null;
		HashMap<Integer, Double> mapB = mapA.get(b);
		if (mapB == null)
			return null;
		return mapB.get(c);
	}

	private void putCachedExploreValue(Integer a, Integer b, Integer c,
			Double value) {
		HashMap<Integer, HashMap<Integer, Double>> mapA;
		HashMap<Integer, Double> mapB;

		mapA = this.exploreValues.get(a);
		if (mapA == null) {
			mapA = new HashMap<Integer, HashMap<Integer, Double>>();
			mapB = new HashMap<Integer, Double>();
		} else {
			mapB = mapA.get(b);
			if (mapB == null) {
				mapB = new HashMap<Integer, Double>();
			}
		}
		mapB.put(c, value);
		mapA.put(b, mapB);
		this.exploreValues.put(a, mapA);
	}

	private Double getCachedExploitValue(Integer a, Integer b, Integer c) {
		HashMap<Integer, HashMap<Integer, Double>> mapA = this.exploitValues
				.get(a);
		if (mapA == null)
			return null;
		HashMap<Integer, Double> mapB = mapA.get(b);
		if (mapB == null)
			return null;
		return mapB.get(c);
	}

	private void putCachedExploitValue(Integer a, Integer b, Integer c,
			Double value) {
		HashMap<Integer, HashMap<Integer, Double>> mapA;
		HashMap<Integer, Double> mapB;

		mapA = this.exploitValues.get(a);
		if (mapA == null) {
			mapA = new HashMap<Integer, HashMap<Integer, Double>>();
			mapB = new HashMap<Integer, Double>();
		} else {
			mapB = mapA.get(b);
			if (mapB == null) {
				mapB = new HashMap<Integer, Double>();
			}
		}
		mapB.put(c, value);
		mapA.put(b, mapB);
		this.exploitValues.put(a, mapA);
	}

	private Boolean getCachedAction(Integer a, Integer b, Integer c) {
		HashMap<Integer, HashMap<Integer, Boolean>> mapA = this.actions.get(a);
		if (mapA == null)
			return null;
		HashMap<Integer, Boolean> mapB = mapA.get(b);
		if (mapB == null)
			return null;
		return mapB.get(c);
	}

	private void putCachedAction(Integer a, Integer b, Integer c, Boolean value) {
		HashMap<Integer, HashMap<Integer, Boolean>> mapA;
		HashMap<Integer, Boolean> mapB;

		mapA = this.actions.get(a);
		if (mapA == null) {
			mapA = new HashMap<Integer, HashMap<Integer, Boolean>>();
			mapB = new HashMap<Integer, Boolean>();
		} else {
			mapB = mapA.get(b);
			if (mapB == null) {
				mapB = new HashMap<Integer, Boolean>();
			}
		}
		mapB.put(c, value);
		mapA.put(b, mapB);
		this.actions.put(a, mapA);
	}

	private double probSurvive(Integer a_from, Integer b_from, Integer c_from, Integer a_to, Integer b_to, Integer c_to) {
		us.quizz.service.SurvivalProbabilityService.Result result 
			= survivalProbabilityService.getSurvivalProbability(null, a_from, a_to, b_from, b_to);
		double pSurvival = result.getPsurvival();
		
		if(pSurvival == 0)
			return 1;
		
		return Math.pow(0.5, pSurvival) / Math.pow(0.5, pSurvival - 1);
	}

	private double computeValue(Integer a, Integer b, Integer c, Double Uq,
			int limit) throws Exception {

		if (limit == 0) {
			return 0;
		}

		Double result = getCachedValue(a, b, c);
		if (result != null)
			return result;

		
		double ig = Helper
				.getBayesianMeanInformationGain(a + 1, b + (N - 1), N);
		double vig = Helper.getBayesianInformationGainSquare(a + 1,
				b + (N - 1), N);
		double UexploitNow = (ig - 0.75 * Math.sqrt(vig));
		// double UexploitNow = ig;
		double UexploitFuture = computeValue(a, b, c + 1, UexploitNow,
				limit - 1);
		
		double gammaExploit = probSurvive(a, b, c, a, b, c+1);
		double Uexploit = gammaExploit * (UexploitNow + UexploitFuture);

		double q = (a + 1.0) / (a + b + N);

		double igCorr = Helper.getBayesianMeanInformationGain(a + 1, b
				+ (N - 1), N);
		double vigCorr = Helper.getBayesianInformationGainSquare(a + 1, b
				+ (N - 1), N);
		// double UquestionCorr = igCorr;
		double UquestionCorr = (igCorr - 0.75 * Math.sqrt(vigCorr));
		double UexploreNowCorr = c * (UquestionCorr - Uq);

		double UexploreFutureCorr = computeValue(a + 1, b, c, UquestionCorr,
				limit - 1);
		double UexploreCorr = q * (UexploreNowCorr + UexploreFutureCorr);

		double igIncorr = Helper.getBayesianMeanInformationGain(a, b + 1
				+ (N - 1), N);
		double vigIncorr = Helper.getBayesianInformationGainSquare(a, b + 1
				+ (N - 1), N);
		// double UquestionIncorr = igIncorr;
		double UquestionIncorr = (igIncorr - 0.75 * Math.sqrt(vigIncorr));
		double UexploreNowIncorr = c * (UquestionIncorr - Uq);
		double UexploreFutureIncorr = computeValue(a, b + 1, c,
				UquestionIncorr, limit - 1);
		double UexploreIncorr = (1 - q)
				* (UexploreNowIncorr + UexploreFutureIncorr);

		double gammaExploreCorr = probSurvive(a, b, c, a+1, b, c);
		double gammaExploreIncorr = probSurvive(a, b, c, a, b+1, c);
		
		
		double Uexplore = gammaExploreCorr * UexploreCorr + gammaExploreIncorr * UexploreIncorr;

		result = Math.max(Uexploit, Uexplore);
		putCachedValue(a, b, c, result);
		putCachedExploitValue(a, b, c, Uexploit);
		putCachedExploreValue(a, b, c, Uexplore);
		putCachedAction(a, b, c, (Uexploit > Uexplore));
		return result;
	}

	public Result getUtility(Integer a, Integer b, Integer c, Double epsilon)
			throws Exception {

		double diff = Double.MAX_VALUE;
		double diffExplore = Double.MAX_VALUE;
		double diffExploit = Double.MAX_VALUE;
		int i = 1;
		computeValue(a, b, c, 0.0, i);
		Double explore = getCachedExploreValue(a, b, c);
		Double exploit = getCachedExploitValue(a, b, c);
		do {
			// System.out.println(i+ "\tV = "+ getCachedValue(a,b,c) + "\t R=" +
			// getCachedExploreValue(a,b,c) + "\t T=" +
			// getCachedExploitValue(a,b,c) + "\t" + getCachedAction(a,b,c));
			i++;
			double tExplore = explore;
			double tExploit = exploit;
			cleanCache();
			computeValue(a, b, c, 0.0, i);
			explore = getCachedExploreValue(a, b, c);
			exploit = getCachedExploitValue(a, b, c);
			diffExplore = Math.abs(explore - tExplore);
			diffExploit = Math.abs(exploit - tExploit);
			diff = Math.abs(explore - exploit);
			// System.out.println(i+ "\tdiff   = "+ diffExplore + "\t" +
			// diffExploit + "\t" + diff);

		} while ((diffExplore > epsilon || diffExploit > epsilon
				|| diff < diffExplore || diff < diffExploit));
		/*
		 * System.out.println("A="+a+" B="+b+" C="+c);
		 * System.out.println("Horizon = "+i);
		 * System.out.println("Value   = "+getCachedValue(a,b,c));
		 * System.out.println("Explore = "+getCachedExploreValue(a,b,c));
		 * System.out.println("Exploit = "+getCachedExploitValue(a,b,c));
		 * System.out.println("Action  = "+getCachedAction(a,b,c));
		 */

		Result r = new Result();
		r.a = a;
		r.b = b;
		r.c = c;
		r.value = getCachedValue(a, b, c);
		r.action = getCachedAction(a, b, c);
		r.exploit = getCachedExploitValue(a, b, c);
		r.explore = getCachedExploreValue(a, b, c);

		return r;

	}

	// We first impose a prior B(2/n, 2*(n-1)/n).
	// This ensures that we have the same "stickiness" in
	// updating the prior probabilities as the Beta(1,1) uniform prior
	// but also ensures that the mean quality of the prior expectation
	// is equal to 1/n, i.e., random
	//
	// double a = correct + 2.0/n;
	// double b = incorrect+2*(n-1.0)/n;
	//
	// Good idea, in theory, breaks the dynamic programming optimization in
	// reality.
	// Shelving it, and continuing with B(1,n-1) as prior.

	public static void main(String[] args) throws Exception {

		NumberFormat format = NumberFormat.getInstance();
		format.setMinimumFractionDigits(3);
		format.setMaximumFractionDigits(3);
		/*
		int n = 4;
		ExplorationExploitation t = new ExplorationExploitation();

		/*
		 * int limit = 30; for (int a=1; a<limit; a++) { for (int b=1; b<limit;
		 * b++) { double ig = Helper.getBayesianInformationGain(a, b,
		 * n)/Math.log(2); double vig =
		 * Helper.getBayesianInformationGainSquare(a, b,
		 * n)/(Math.log(2)*Math.log(2)); double var = Math.sqrt(vig - ig*ig);
		 * double score = (ig-var);
		 * System.out.println("a="+a+"\tb="+b+"\tig="+format
		 * .format(ig)+"\tvig="+
		 * format.format(vig)+"\tvar="+format.format(var)+"\tscore="
		 * +format.format(score));
		 * //System.out.println("a="+a+"\tb="+b+"\tE[H]="
		 * +format.format(e)+"\tE[H^2]="
		 * +format.format(e2)+"\tE[H]*E[H]="+format.
		 * format(e*e)+"\tE[H^2]-E[H]*E[H]="+format.format(e2-e*e)); } }
		 

		int limit = 15;
		double epsilon = 0.01;
		for (int k = 0; k < 5; k++) {
			for (int i = 1; i < limit; i++) {
				for (int j = 1; j < limit; j++) {
					Result r = t.getUtility(i, j, k, epsilon);
					System.out.print(r.toString() + "\t");
				}
				System.out.println("");
			}
			System.out.println("");
		}*/

	}
	
	public class Result {

		Integer a, b, c;
		Double value;
		Boolean action;
		Double explore;
		Double exploit;

		public String toString() {

			NumberFormat format = NumberFormat.getInstance();
			format.setMinimumFractionDigits(4);
			format.setMaximumFractionDigits(4);

			StringBuffer sb = new StringBuffer();
			sb.append("[" + a + "," + b + "," + c + "]: V=");
			sb.append(format.format(value));
			sb.append("/R=");
			sb.append(format.format(explore));
			sb.append("/T=");
			sb.append(format.format(exploit));
			sb.append("/Exploit=");
			sb.append(action + "\t");

			return sb.toString();
		}

		public Boolean getAction() {
			return action;
		}
	}

	public void setN(Integer n) {
		N = n;
	}
}
