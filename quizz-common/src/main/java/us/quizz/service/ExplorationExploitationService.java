package us.quizz.service;

import com.google.inject.Inject;

import us.quizz.entities.ExplorationExploitationResult;
import us.quizz.entities.SurvivalProbabilityResult;
import us.quizz.repository.QuizPerformanceRepository;
import us.quizz.utils.CachePMF;
import us.quizz.utils.Helper;
import us.quizz.utils.MemcacheKey;

import java.text.NumberFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;

public class ExplorationExploitationService {
  private static Logger logger = Logger.getLogger(ExplorationExploitationService.class.getName());
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> values;
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> exploreValues;
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> exploitValues;
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Boolean>>> actions;

  private Integer N;
  // We either use the IG per se, or the IG-VIG to accommodate for value of
  // learning
  private static boolean useIG = false;
  // The accuracy threshold for convergence
  private static double EPSILON = 0.01;
  // Number of minutes to cache the actions in Memcache.
  private static final int CACHED_TIME_MINS = 24 * 60; // 24 hours.
  // How much ahead to look in exploration/exploitation
  private static final int HORIZON = 20; // 24 hours.

  public static void main(String[] args) {
    NumberFormat format = NumberFormat.getInstance();
    format.setMinimumFractionDigits(3);
    format.setMaximumFractionDigits(3);

    int n = 4;

    QuizPerformanceRepository qp = new QuizPerformanceRepository();
    SurvivalProbabilityService s = new SurvivalProbabilityService(qp);
    ExplorationExploitationService t = new ExplorationExploitationService(s);
    t.setN(n);

    int limit = 15;
    for (int k = 0; k < 5; k++) {
      for (int i = 0; i < limit; i++) {
        for (int j = 0; j < limit; j++) {
          ExplorationExploitationResult r = t.getUtility(i, j, k);
          System.out.print(r.print() + "\t");
        }
        System.out.println("");
      }
      System.out.println("");
    }
  }

  private SurvivalProbabilityService survivalProbabilityService;

  @Inject
  public ExplorationExploitationService(SurvivalProbabilityService survivalProbabilityService) {
    this.survivalProbabilityService = survivalProbabilityService;
    cleanCache();
  }

  public void cacheValuesInMemcache(int a, int b, int c) {
    String key = MemcacheKey.getExploreExploitAction(a, b, c, this.N);
    ExplorationExploitationResult r = getUtility(a, b, c);
    CachePMF.put(key, r, CACHED_TIME_MINS * 60);
    logger.log(Level.INFO, r.print());
  }

  public void cleanCache() {
    this.values = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
    this.exploreValues = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
    this.exploitValues = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
    this.actions = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Boolean>>>();
  }

  private double computeValue(Integer a, Integer b, Integer c, Double Uq, int limit) {
    if (limit == 0) {
      return 0;
    }

    Double result = getCachedValue(a, b, c);
    if (result != null) {
      return result;
    }

    double Uexploit = 0.0;
    double Uexplore = 0.0;
    try {
      double ig = Helper.getBayesianMeanInformationGain(a + 1, b + (N - 1), N);
      double vig = Helper.getBayesianInformationGainSquare(a + 1, b + (N - 1), N);

      double UexploitNow = useIG ? ig : (ig - 0.75 * Math.sqrt(vig));
      double UexploitFuture = computeValue(a, b, c + 1, UexploitNow, limit - 1);

      double gammaExploit = probSurvive(a, b, c, a, b, c + 1);
      Uexploit = gammaExploit * (UexploitNow + UexploitFuture);

      double q = (a + 1.0) / (a + b + N);

      double igCorr = Helper.getBayesianMeanInformationGain(a + 1, b + (N - 1), N);
      double vigCorr = Helper.getBayesianInformationGainSquare(a + 1, b + (N - 1), N);
      double UquestionCorr = useIG ? igCorr : (igCorr - 0.75 * Math.sqrt(vigCorr));
      double UexploreNowCorr = c * (UquestionCorr - Uq);

      double UexploreFutureCorr = computeValue(a + 1, b, c, UquestionCorr, limit - 1);
      double UexploreCorr = q * (UexploreNowCorr + UexploreFutureCorr);

      double igIncorr = Helper.getBayesianMeanInformationGain(a, b + 1 + (N - 1), N);
      double vigIncorr = Helper.getBayesianInformationGainSquare(a, b + 1 + (N - 1), N);
      double UquestionIncorr = useIG ? igIncorr : (igIncorr - 0.75 * Math.sqrt(vigIncorr));
      double UexploreNowIncorr = c * (UquestionIncorr - Uq);
      double UexploreFutureIncorr = computeValue(a, b + 1, c, UquestionIncorr, limit - 1);
      double UexploreIncorr = (1 - q) * (UexploreNowIncorr + UexploreFutureIncorr);

      double gammaExploreCorr = probSurvive(a, b, c, a + 1, b, c);
      double gammaExploreIncorr = probSurvive(a, b, c, a, b + 1, c);

      Uexplore = gammaExploreCorr * UexploreCorr + gammaExploreIncorr * UexploreIncorr;
    } catch (Exception e) {
      logger.log(Level.SEVERE, e.getMessage());
    }

    result = Math.max(Uexploit, Uexplore);
    putCachedValue(a, b, c, result);
    putCachedExploitValue(a, b, c, Uexploit);
    putCachedExploreValue(a, b, c, Uexplore);
    putCachedAction(a, b, c, (Uexploit > Uexplore));
    return result;
  }

  public ExplorationExploitationResult getAction(Integer a, Integer b, Integer c) {
    String key = MemcacheKey.getExploreExploitAction(a, b, c, this.N);
    ExplorationExploitationResult r = CachePMF.get(key, ExplorationExploitationResult.class);

    if (r == null) {
      r = new ExplorationExploitationResult(a, b, c);
      r.setActionExploit(false);
    }
    return r;
  }

  private Boolean getCachedAction(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Boolean>> mapA = this.actions.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Boolean> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private Double getCachedExploitValue(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Double>> mapA = this.exploitValues.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Double> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private Double getCachedExploreValue(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Double>> mapA = this.exploreValues.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Double> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private Double getCachedValue(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Double>> mapA = this.values.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Double> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private ExplorationExploitationResult getUtility(Integer a, Integer b, Integer c) {
    double diff = Double.MAX_VALUE;
    double diffExplore = Double.MAX_VALUE;
    double diffExploit = Double.MAX_VALUE;
    int i = 1;
    computeValue(a, b, c, 0.0, i);
    Double explore = getCachedExploreValue(a, b, c);
    Double exploit = getCachedExploitValue(a, b, c);
    do {
      i++;
      if (i > HORIZON)
        break;
      double tExplore = explore;
      double tExploit = exploit;
      cleanCache();
      computeValue(a, b, c, 0.0, i);
      explore = getCachedExploreValue(a, b, c);
      exploit = getCachedExploitValue(a, b, c);
      diffExplore = Math.abs(explore - tExplore);
      diffExploit = Math.abs(exploit - tExploit);
      diff = Math.abs(explore - exploit);
    } while (diffExplore > EPSILON || diffExploit > EPSILON ||
             diff < diffExplore || diff < diffExploit);

    ExplorationExploitationResult r = new ExplorationExploitationResult(a, b, c);
    r.setActionExploit(getCachedAction(a, b, c));
    r.setUtility(getCachedValue(a, b, c));
    r.setExploitUtility(getCachedExploitValue(a, b, c));
    r.setExploreUtility(getCachedExploreValue(a, b, c));
    r.setIterations(i);
    r.setTimestamp(new Date());

    return r;
  }

  private double probSurvive(Integer a_from, Integer b_from, Integer c_from,
                             Integer a_to, Integer b_to, Integer c_to) {
    // TODO (Panos): Since we do not have sufficient statistics for the exploit actions, the
    // function does not use the c_from and c_to values
    // We should modify the survivalProbablity service to control for that.
    SurvivalProbabilityResult result = survivalProbabilityService.getSurvivalProbability(
        null, a_from, a_to, b_from, b_to, c_from, c_to);
    double pSurvival = result.getProbSurvival();

    // TODO: The Math.pow(0.5, c_to-c_from) part is just to add a discounting factor for the exploit actions.
    return Math.pow(0.5, c_to-c_from)*pSurvival;
  }

  private void putCachedAction(Integer a, Integer b, Integer c, Boolean value) {
    HashMap<Integer, HashMap<Integer, Boolean>> mapA;
    HashMap<Integer, Boolean> mapB;

    mapA = this.actions.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Boolean>>();
      mapB = new HashMap<Integer, Boolean>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Boolean>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.actions.put(a, mapA);
  }

  private void putCachedExploitValue(Integer a, Integer b, Integer c, Double value) {
    HashMap<Integer, HashMap<Integer, Double>> mapA;
    HashMap<Integer, Double> mapB;

    mapA = this.exploitValues.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Double>>();
      mapB = new HashMap<Integer, Double>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Double>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.exploitValues.put(a, mapA);
  }

  private void putCachedExploreValue(Integer a, Integer b, Integer c, Double value) {
    HashMap<Integer, HashMap<Integer, Double>> mapA;
    HashMap<Integer, Double> mapB;

    mapA = this.exploreValues.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Double>>();
      mapB = new HashMap<Integer, Double>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Double>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.exploreValues.put(a, mapA);
  }

  private void putCachedValue(Integer a, Integer b, Integer c, Double value) {
    HashMap<Integer, HashMap<Integer, Double>> mapA;
    HashMap<Integer, Double> mapB;

    mapA = this.values.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Double>>();
      mapB = new HashMap<Integer, Double>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Double>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.values.put(a, mapA);
  }

  public void setN(Integer n) {
    N = n;
  }
}
