package us.quizz.service;

import java.text.NumberFormat;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;

import us.quizz.repository.QuizPerformanceRepository;
import us.quizz.utils.CachePMF;
import us.quizz.utils.Helper;
import us.quizz.utils.MemcacheKey;

import com.google.inject.Inject;

public class ExplorationExploitationService {


  public class Result {
    
    private int a, b, c;
    private double value;
    private int iterations;
    private boolean actionExploit;
    private double explore;
    private double exploit;

    public Result(Integer a, Integer b, Integer c, Double v, Boolean action, Double xplr, Double xplt, Integer i) {
      this.a=a;
      this.b=b;
      this.c=c;
      this.value=v;
      this.actionExploit=action;
      this.explore=xplr;
      this.exploit=xplt;
      this.iterations=i;
          
    }
    
    


    public int getA() {
      return a;
    }




    public void setA(int a) {
      this.a = a;
    }




    public int getB() {
      return b;
    }




    public void setB(int b) {
      this.b = b;
    }




    public int getC() {
      return c;
    }




    public void setC(int c) {
      this.c = c;
    }




    public double getValue() {
      return value;
    }




    public void setValue(double value) {
      this.value = value;
    }




    public int getIterations() {
      return iterations;
    }




    public void setIterations(int iterations) {
      this.iterations = iterations;
    }




    public boolean isActionExploit() {
      return actionExploit;
    }




    public void setActionExploit(boolean actionExploit) {
      this.actionExploit = actionExploit;
    }




    public double getExplore() {
      return explore;
    }




    public void setExplore(double explore) {
      this.explore = explore;
    }




    public double getExploit() {
      return exploit;
    }




    public void setExploit(double exploit) {
      this.exploit = exploit;
    }




    public String print() {
      NumberFormat format = NumberFormat.getInstance();
      format.setMinimumFractionDigits(4);
      format.setMaximumFractionDigits(4);

      StringBuffer sb = new StringBuffer();
      sb.append("[" + a + "," + b + "," + c + "]: V=");
      sb.append(format.format(value));
      sb.append("/R=");
      sb.append(format.format(explore));
      sb.append("/T=");
      sb.append(format.format(exploit));
      sb.append("/Exploit=");
      sb.append(actionExploit + "\t");

      return sb.toString();
    }

  }

  private static final Logger logger = Logger.getLogger(ExplorationExploitationService.class.getName());
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> values;
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> exploreValues;
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>> exploitValues;
  private HashMap<Integer, HashMap<Integer, HashMap<Integer, Boolean>>> actions;

  private Integer N;
  // We either use the IG per se, or the IG-VIG to accommodate for value of
  // learning
  private static boolean useIG = false;
  // The accuracy threshold for convergence
  private static double EPSILON = 0.01;
  // Number of minutes to cache the actions in Memcache.
  private static final int CACHED_TIME_MINS = 24 * 60; // 24 hours.
  // How much ahead to look in exploration/exploitation
  private static final int HORIZON = 20; // 24 hours.

  public static void main(String[] args) {
    NumberFormat format = NumberFormat.getInstance();
    format.setMinimumFractionDigits(3);
    format.setMaximumFractionDigits(3);

    int n = 4;

    QuizPerformanceRepository qp = new QuizPerformanceRepository();
    SurvivalProbabilityService s = new SurvivalProbabilityService(qp);
    ExplorationExploitationService t = new ExplorationExploitationService(s);
    t.setN(n);

    int limit = 15;
    for (int k = 0; k < 5; k++) {
      for (int i = 0; i < limit; i++) {
        for (int j = 0; j < limit; j++) {
          Result r = t.getUtility(i, j, k);
          System.out.print(r.print() + "\t");
        }
        System.out.println("");
      }
      System.out.println("");
    }
  }

  private SurvivalProbabilityService survivalProbabilityService;

  private Set<String> set = new HashSet<String>();

  @Inject
  public ExplorationExploitationService(SurvivalProbabilityService survivalProbabilityService) {
    this.survivalProbabilityService = survivalProbabilityService;
    cleanCache();
  }

  public void cacheValuesInMemcache(Integer a, Integer b, Integer c) {
    String key = MemcacheKey.getExploreExploitAction(a, b, c, this.N);
    Result r = getUtility(a, b, c);
    CachePMF.put(key, r, CACHED_TIME_MINS * 60);
  }

  public void cleanCache() {
    this.values = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
    this.exploreValues = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
    this.exploitValues = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Double>>>();
    this.actions = new HashMap<Integer, HashMap<Integer, HashMap<Integer, Boolean>>>();
  }

  private double computeValue(Integer a, Integer b, Integer c, Double Uq, int limit) {

    if (limit == 0) {
      return 0;
    }

    Double result = getCachedValue(a, b, c);
    if (result != null) {
      return result;
    }

    double Uexploit = 0.0;
    double Uexplore = 0.0;
    try {
      double ig = Helper.getBayesianMeanInformationGain(a + 1, b + (N - 1), N);
      double vig = Helper.getBayesianInformationGainSquare(a + 1, b + (N - 1), N);

      double UexploitNow = useIG ? ig : (ig - 0.75 * Math.sqrt(vig));
      double UexploitFuture = computeValue(a, b, c + 1, UexploitNow, limit - 1);

      double gammaExploit = probSurvive(a, b, c, a, b, c + 1);
      Uexploit = gammaExploit * (UexploitNow + UexploitFuture);

      double q = (a + 1.0) / (a + b + N);

      double igCorr = Helper.getBayesianMeanInformationGain(a + 1, b + (N - 1), N);
      double vigCorr = Helper.getBayesianInformationGainSquare(a + 1, b + (N - 1), N);
      double UquestionCorr = useIG ? igCorr : (igCorr - 0.75 * Math.sqrt(vigCorr));
      double UexploreNowCorr = c * (UquestionCorr - Uq);

      double UexploreFutureCorr = computeValue(a + 1, b, c, UquestionCorr, limit - 1);
      double UexploreCorr = q * (UexploreNowCorr + UexploreFutureCorr);

      double igIncorr = Helper.getBayesianMeanInformationGain(a, b + 1 + (N - 1), N);
      double vigIncorr = Helper.getBayesianInformationGainSquare(a, b + 1 + (N - 1), N);
      double UquestionIncorr = useIG ? igIncorr : (igIncorr - 0.75 * Math.sqrt(vigIncorr));
      double UexploreNowIncorr = c * (UquestionIncorr - Uq);
      double UexploreFutureIncorr = computeValue(a, b + 1, c, UquestionIncorr, limit - 1);
      double UexploreIncorr = (1 - q) * (UexploreNowIncorr + UexploreFutureIncorr);

      double gammaExploreCorr = probSurvive(a, b, c, a + 1, b, c);
      double gammaExploreIncorr = probSurvive(a, b, c, a, b + 1, c);

      Uexplore = gammaExploreCorr * UexploreCorr + gammaExploreIncorr * UexploreIncorr;
    } catch (Exception e) {
      logger.log(Level.SEVERE, e.getMessage());
    }

    result = Math.max(Uexploit, Uexplore);
    putCachedValue(a, b, c, result);
    putCachedExploitValue(a, b, c, Uexploit);
    putCachedExploreValue(a, b, c, Uexplore);
    putCachedAction(a, b, c, (Uexploit < Uexplore));
    return result;
  }

  public Result getAction(Integer a, Integer b, Integer c) {
    String key = MemcacheKey.getExploreExploitAction(a, b, c, this.N);
    Result result = CachePMF.get(key, Result.class);
    if (result != null) {
      return result;
    } else {
      Result r = new Result(0,0,0,0.0,false,0.0,0.0,0);
  
      return r;
    }
  }

  private Boolean getCachedAction(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Boolean>> mapA = this.actions.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Boolean> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private Double getCachedExploitValue(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Double>> mapA = this.exploitValues.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Double> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private Double getCachedExploreValue(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Double>> mapA = this.exploreValues.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Double> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  private Double getCachedValue(Integer a, Integer b, Integer c) {
    HashMap<Integer, HashMap<Integer, Double>> mapA = this.values.get(a);
    if (mapA == null) {
      return null;
    }
    HashMap<Integer, Double> mapB = mapA.get(b);
    if (mapB == null) {
      return null;
    }
    return mapB.get(c);
  }

  public Set<String> getSet() {
    return set;
  }

  private Result getUtility(Integer a, Integer b, Integer c) {
    double diff = Double.MAX_VALUE;
    double diffExplore = Double.MAX_VALUE;
    double diffExploit = Double.MAX_VALUE;
    int i = 1;
    computeValue(a, b, c, 0.0, i);
    Double explore = getCachedExploreValue(a, b, c);
    Double exploit = getCachedExploitValue(a, b, c);
    do {
      i++;
      if (i > HORIZON)
        break;
      double tExplore = explore;
      double tExploit = exploit;
      cleanCache();
      computeValue(a, b, c, 0.0, i);
      explore = getCachedExploreValue(a, b, c);
      exploit = getCachedExploitValue(a, b, c);
      diffExplore = Math.abs(explore - tExplore);
      diffExploit = Math.abs(exploit - tExploit);
      diff = Math.abs(explore - exploit);
    } while (diffExplore > EPSILON || diffExploit > EPSILON || diff < diffExplore || diff < diffExploit);

    Result r = new Result(a,b,c,getCachedValue(a, b, c), getCachedAction(a, b, c), getCachedExploreValue(a, b, c) , getCachedExploitValue(a, b, c), i );

    return r;
  }

  private double probSurvive(Integer a_from, Integer b_from, Integer c_from, Integer a_to, Integer b_to, Integer c_to) {

    us.quizz.service.SurvivalProbabilityService.Result result = survivalProbabilityService.getSurvivalProbability(null, a_from,
        a_to, b_from, b_to);
    double pSurvival = result.getPsurvival();

    return pSurvival;

  }

  private void putCachedAction(Integer a, Integer b, Integer c, Boolean value) {
    HashMap<Integer, HashMap<Integer, Boolean>> mapA;
    HashMap<Integer, Boolean> mapB;

    mapA = this.actions.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Boolean>>();
      mapB = new HashMap<Integer, Boolean>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Boolean>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.actions.put(a, mapA);
  }

  private void putCachedExploitValue(Integer a, Integer b, Integer c, Double value) {
    HashMap<Integer, HashMap<Integer, Double>> mapA;
    HashMap<Integer, Double> mapB;

    mapA = this.exploitValues.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Double>>();
      mapB = new HashMap<Integer, Double>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Double>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.exploitValues.put(a, mapA);
  }
  
  private void putCachedExploreValue(Integer a, Integer b, Integer c, Double value) {
    HashMap<Integer, HashMap<Integer, Double>> mapA;
    HashMap<Integer, Double> mapB;

    mapA = this.exploreValues.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Double>>();
      mapB = new HashMap<Integer, Double>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Double>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.exploreValues.put(a, mapA);
  }

  private void putCachedValue(Integer a, Integer b, Integer c, Double value) {
    HashMap<Integer, HashMap<Integer, Double>> mapA;
    HashMap<Integer, Double> mapB;

    mapA = this.values.get(a);
    if (mapA == null) {
      mapA = new HashMap<Integer, HashMap<Integer, Double>>();
      mapB = new HashMap<Integer, Double>();
    } else {
      mapB = mapA.get(b);
      if (mapB == null) {
        mapB = new HashMap<Integer, Double>();
      }
    }
    mapB.put(c, value);
    mapA.put(b, mapB);
    this.values.put(a, mapA);
  }

  public void setN(Integer n) {
    N = n;
  }


}
